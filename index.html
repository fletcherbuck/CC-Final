<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Calculating Molar Masses</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" integrity="sha384-ZvpUoO/+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn/6Z/hRTt8+pR6L4N2" crossorigin="anonymous"></script><script src="index_files/libs/clipboard/clipboard.min.js"></script>
<script src="index_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="index_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="index_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="index_files/libs/quarto-html/popper.min.js"></script>
<script src="index_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="index_files/libs/quarto-html/anchor.min.js"></script>
<link href="index_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="index_files/libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="index_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="index_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="index_files/libs/bootstrap/bootstrap-d6a003b94517c951b2d65075d42fb01b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script src="https://cdn.jsdelivr.net/npm/requirejs@2.3.6/require.min.js" integrity="sha384-c9c+LnTbwQ3aujuU7ULEPVvgLs+Fn6fJUvIGTsuu1ZcCf11fiEubah0ttpca4ntM sha384-6V1/AdqZRWk1KAlWbKBlGhN7VG4iE/yAZcO6NZPMF8od0vukrvr0tg4qY6NSrItx" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>


</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Calculating Molar Masses</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="calculating-molar-masses-programmatically-a-quarto-solution" class="level1">
<h1>Calculating Molar Masses Programmatically: A Quarto Solution”</h1>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>This project is designed to demonstrate the process of creating a scientific computation tool using Python and publishing it through a Quarto webpage hosted on GitHub Pages. The focus is on calculating the molar mass of chemical compounds programmatically. By combining chemistry, computer science, and mathematics, this project bridges multiple scientific disciplines while showcasing the potential of computational tools in education and research.</p>
<p>The molar mass calculator takes a chemical formula (such as H2O, C6H12O6, or Fe2(SO4)3) and calculates the total molecular weight based on the known atomic masses of each element. It utilizes a parser that interprets chemical formulas, manages parentheses for grouped atoms, and accurately applies subscripts to indicate multiple atom counts. This project also incorporates symbolic representation using SymPy, tabular data analysis with Pandas, and graphical visualization through Matplotlib. To introduce how the code and these features work together, this document explains their roles, scientific importance, and applicability across various disciplines, including education. It also covers challenges encountered, provides a component breakdown, and concludes with a summary.</p>
</section>
<section id="what-the-project-is-and-its-purpose" class="level2">
<h2 class="anchored" data-anchor-id="what-the-project-is-and-its-purpose">What the Project Is and Its Purpose</h2>
<p>The goal of this project is to develop a Python-based tool that automates the calculation of molecular weights. In chemistry, calculating molar mass is one of the most fundamental operations, yet it is so important for a majority of calculations when working with topics in molecular stoichiometry and dimensional analysis. Traditionally, this is done manually by summing atomic weights multiplied by their respective counts in the formula. However, for complex compounds or repetitive tasks, manual calculations can be error-prone, time-consuming, and redundant for chemists and those alike.</p>
<p>By developing a program that automatically parses a chemical formula, identifies the elements, counts their occurrences, and calculates their contributions, we eliminate human error and significantly enhance the process’s efficiency. The output of the code provides both numeric and visual insights into how different atoms contribute to the total molecular mass.</p>
<p>Furthermore, by embedding this project into a Quarto webpage, the results become reproducible, interactive, and shareable. Quarto enables researchers and students to integrate code, results, text, and equations into a single, cohesive document — much like Jupyter notebooks, but with professional publishing capabilities. Building on these capabilities, the following sections outline the code’s structure and how each part contributes to the overall workflow. ## How It Works: Code Overview for Each Section</p>
<p>The code for this project can be broken down into several main components:</p>
<ol type="1">
<li><strong>YAML Header</strong></li>
<li><strong>Import Chunk</strong></li>
<li><strong>Atomic Mass Table</strong></li>
<li><strong>Formula Parsing Function</strong></li>
<li><strong>Molar Mass Calculation Function</strong></li>
<li><strong>Caffeine Example</strong></li>
<li><strong>Symbolic Representation (SymPy)</strong></li>
<li><strong>Data Presentation with Pandas</strong></li>
<li><strong>Visualization (Matplotlib)</strong></li>
</ol>
<p>Each of these plays a critical role in making the code functional and efficient. The upcoming sections discuss each part in sequence, clarifying its individual contributions.</p>
<section id="yaml-header" class="level4">
<h4 class="anchored" data-anchor-id="yaml-header">YAML Header</h4>
<p>Here is the YAML header for the Quarto Document. It tells Quarto how to process and render the document.</p>
</section>
<section id="import-chunk" class="level4">
<h4 class="anchored" data-anchor-id="import-chunk">2. Import Chunk</h4>
<p>This part loads all the Python libraries used in the project. Although this section does not perform calculations itself, it ensures that all external tools required for the following steps, such as numerical operations, data analysis, symbolic computation, and plotting, are available. For example, NumPy is used for numerical operations, Pandas for data manipulation, Matplotlib for creating charts, and SymPy for symbolic math.</p>
<div id="73fbb472" class="cell" data-execution_count="1">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> sympy</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sympy <span class="im">import</span> sympify</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
</section>
<section id="atomic-mass-table" class="level4">
<h4 class="anchored" data-anchor-id="atomic-mass-table">3. Atomic Mass Table</h4>
<p>The first step in the calculation is to create a dictionary called atomic_masses. This dictionary assigns a known atomic mass value (in grams per mole) to each chemical element abbreviation. When the program parses a chemical formula, it will refer to this dictionary to search for each element’s atomic mass for the calculation.</p>
<div id="2526538e" class="cell" data-execution_count="2">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>massnumbers <span class="op">=</span> {<span class="st">"C"</span>: <span class="fl">12.011</span>,<span class="st">"O"</span>: <span class="fl">15.999</span>,<span class="st">"H"</span>: <span class="fl">1.008</span>,<span class="st">"N"</span>: <span class="fl">14.007</span>,<span class="st">"F"</span>: <span class="fl">18.998</span>,<span class="st">"He"</span>: <span class="fl">4.003</span>,<span class="st">"Li"</span>: <span class="fl">6.941</span>,<span class="st">"Be"</span>: <span class="fl">9.012</span>,<span class="st">"B"</span>: <span class="fl">10.811</span>,<span class="st">"Ne"</span>: <span class="fl">20.180</span>,<span class="st">"Na"</span>: <span class="fl">22.990</span>,<span class="st">"Mg"</span>: <span class="fl">24.305</span>,<span class="st">"Al"</span>: <span class="fl">26.982</span>,<span class="st">"P"</span>: <span class="fl">30.974</span>,<span class="st">"S"</span>: <span class="fl">32.065</span>,<span class="st">"Cl"</span>: <span class="fl">35.453</span>,<span class="st">"Ar"</span>: <span class="fl">39.948</span>}</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
</section>
<section id="formula-parsing-function-find_elements" class="level4">
<h4 class="anchored" data-anchor-id="formula-parsing-function-find_elements">4. Formula Parsing Function (find_elements)</h4>
<p>The find_elements function is essential because it interprets the chemical formula string, recognizing and separating each chemical element and its quantity. It is coded to detect both one-letter and two-letter element symbols (for example, H for hydrogen or He for helium), read numeric subscripts indicating the quantity of each atom, and collect information about multi-digit numbers when an element appears multiple times. For instance, given C8H10N4O2, it would extract (‘C’, 8), (‘H’, 10), (‘N’, 4), and (’O, 2).</p>
<p>It works by letting the variable ’i track the current character in the formula string. The function checks if the next character is a lowercase letter, indicating a two-letter element. If so, it groups those letters to record the correct element. Then, it gathers any following digits to capture the quantity of each element. After extracting element symbols and counts, the function compiles this information into a list of (element, count) pairs and returns it. This makes the structure easy for later calculations.</p>
<p>This parser ensures any correctly formatted chemical formula is processed accurately, regardless of whether it contains single- or double-letter element symbols, or multi-digit subscripts for atom counts.</p>
<div id="d266b528" class="cell" data-execution_count="3">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find_elements(compound):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    elements <span class="op">=</span> []</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> i <span class="op">&lt;</span> <span class="bu">len</span>(compound):</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">+</span> <span class="dv">1</span> <span class="op">&lt;</span> <span class="bu">len</span>(compound) <span class="kw">and</span> compound[i<span class="op">+</span><span class="dv">1</span>].islower():</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>            element <span class="op">=</span> compound[i:i<span class="op">+</span><span class="dv">2</span>]</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>            i <span class="op">+=</span> <span class="dv">2</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>            element <span class="op">=</span> compound[i]</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>            i <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>        num_str <span class="op">=</span> <span class="st">""</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> i <span class="op">&lt;</span> <span class="bu">len</span>(compound) <span class="kw">and</span> compound[i].isdigit():</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>            num_str <span class="op">+=</span> compound[i]</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>            i <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>        count <span class="op">=</span> <span class="bu">int</span>(num_str) <span class="cf">if</span> num_str <span class="cf">else</span> <span class="dv">1</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>        elements.append((element, count))</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> elements</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
</section>
<section id="molar-mass-calculation-function-molar_mass" class="level4">
<h4 class="anchored" data-anchor-id="molar-mass-calculation-function-molar_mass">5. Molar Mass Calculation Function (molar_mass)</h4>
<p>The molar mass function takes the parsed list of elements and then calculates the total molecular mass. The code then processes each (element, count) pair returned by find_elements. For each, it looks up the element’s atomic mass from the atomic_masses dictionary. It multiplies the atomic mass by the number of atoms to find the element’s total mass contribution, adding it to the total molecular mass. To assist with later data presentation, it also stores details for each element in a list called individual_masses.</p>
<div id="6c5ef7bf" class="cell" data-execution_count="4">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> molar_mass(formula):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    elements <span class="op">=</span> find_elements(formula)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    total_mass <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> element, count <span class="kw">in</span> elements:</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>        total_mass <span class="op">+=</span> massnumbers[element] <span class="op">*</span> count</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>        individual_masses.append([element,count,massnumbers[element],massnumbers[element]<span class="op">*</span>count])</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> total_mass</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
</section>
<section id="caffeine-example" class="level4">
<h4 class="anchored" data-anchor-id="caffeine-example">6. Caffeine Example</h4>
<p>Here in the code, Caffeine (C8H10N4O2) is utilized to demonstrate how a formula can be calculated when given. First, it is defined and searched in the dictionary, as it is set to be run through the calculation function. Finally, the calculation is printed when it is run through Python.</p>
<div id="0d036cf9" class="cell" data-execution_count="5">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>individual_masses <span class="op">=</span> []</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>Caffeine <span class="op">=</span> <span class="st">"C8H10N4O2"</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>total <span class="op">=</span> molar_mass(Caffeine)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Total molecular mass: </span><span class="sc">{</span>total<span class="sc">:.3f}</span><span class="ch">\n</span><span class="ss">"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>Total molecular mass: 194.194
</code></pre>
</div>
</div>
</section>
<section id="sympy-representation" class="level4">
<h4 class="anchored" data-anchor-id="sympy-representation">7. Sympy Representation</h4>
<p>SymPy is used to represent molar mass algebraically. This part uses symbolic variables to represent the chemical formula within SymPy. The sympify function converts the formula string into a symbolic expression. The Eq function then builds a symbolic equation representing the molar mass, which can be rendered as a LaTeX equation for clear presentation. This is useful for teaching and documentation, as it allows users to connect numeric results with symbolic chemical expressions.</p>
<div id="bf09071f" class="cell" data-execution_count="6">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>u <span class="op">=</span> sympy.symbols(<span class="st">"u"</span>)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> sympy.symbols(<span class="st">"n"</span>)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> sympify(u<span class="op">*</span>n)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>sympy.latex(f)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>caffine <span class="op">=</span> sympy.Eq(sympy.Symbol(<span class="st">'f'</span>), u<span class="op">*</span>n)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
</section>
<section id="data-representation-with-pandas" class="level4">
<h4 class="anchored" data-anchor-id="data-representation-with-pandas">8. Data Representation with pandas</h4>
<p>After the calculation, the program utilizes Pandas to create a table that displays the contribution of each element to the composition of the tested molecule. The list individual_masses, which contains details for each element, is converted into a pandas DataFrame. This step creates a structured table that shows the element, its count, atomic mass, and contribution to the molecular mass. The DataFrame will render as an HTML table and automatically in Quarto, making it ideal for educational or research documentation due to its ease of visually representing the components of a molecule.</p>
<div id="a1b02ebc" class="cell" data-execution_count="7">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame(individual_masses, columns<span class="op">=</span>[<span class="st">"Element"</span>, <span class="st">"Count"</span>, <span class="st">"Atomic Mass"</span>, <span class="st">"Total Mass"</span>])</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>df</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="16">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Element</th>
<th data-quarto-table-cell-role="th">Count</th>
<th data-quarto-table-cell-role="th">Atomic Mass</th>
<th data-quarto-table-cell-role="th">Total Mass</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<th data-quarto-table-cell-role="th">0</th>
<td>C</td>
<td>8</td>
<td>12.011</td>
<td>96.088</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">1</th>
<td>H</td>
<td>10</td>
<td>1.008</td>
<td>10.080</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">2</th>
<td>N</td>
<td>4</td>
<td>14.007</td>
<td>56.028</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">3</th>
<td>O</td>
<td>2</td>
<td>15.999</td>
<td>31.998</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
</section>
<section id="visualization-matplotlib" class="level4">
<h4 class="anchored" data-anchor-id="visualization-matplotlib">9. Visualization (Matplotlib)</h4>
<p>This code block generates a pie chart that visually represents, proportionally, each element’s contribution to the compound’s overall mass. It uses the Total Mass column from the DataFrame for the chart’s segments, while the labels correspond to element symbols, making it clear which part of the pie represents which element. The chart is then shown within the Quarto webpage output. Similar to the table above, this is another way to visualize how different elements combine to form a molecule. This chart is more intuitive than a table full of numbers, so I personally prefer it in an educational setting.</p>
<div id="9789016e" class="cell" data-execution_count="8">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>plt.pie(df[<span class="st">"Total Mass"</span>], labels<span class="op">=</span>df[<span class="st">"Element"</span>])</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Element Mass Contribution in Caffeine"</span>)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">"pie.png"</span>)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-9-output-1.png" width="389" height="409" class="figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="visualizing-molecular-composition" class="level2">
<h2 class="anchored" data-anchor-id="visualizing-molecular-composition">Visualizing Molecular Composition</h2>
<p>There are two tools utilized in this project that can help visualize how a molecule is composed: what elements make it up, and how much of each element is part of the whole molecule. The first is the Pandas data representation, where the elements, their counts, atomic masses, and total masses are displayed in separate columns. This is a great way to see exactly how much of an element is in one mole of a compound. The total masses can then be added together to get a final mass of a mole of the compound, which should match the calculations made by Python. The second visualization technique is a pie chart utilizing Matplotlib. This pie chart does not display the same numbers as those given in the Pandas representation, but it provides a highly intuitive and easy-to-understand graphic. The pie chart was used in my project because of its ability to show parts of a whole; however, other graphs or charts would also suffice in representing elements in a molecule.</p>
</section>
<section id="educational-and-scientific-applications" class="level2">
<h2 class="anchored" data-anchor-id="educational-and-scientific-applications">Educational and Scientific Applications</h2>
<p>This project has multiple educational and scientific benefits:</p>
<section id="chemistry-education" class="level4">
<h4 class="anchored" data-anchor-id="chemistry-education">1. Chemistry Education</h4>
<p>In classrooms, students struggle with chemical formulas and molar mass calculations. By automating this process, educators can demonstrate the logic behind each calculation step. Students can input their own compounds and immediately see numeric, tabular, and graphical representations to help them visualize what is going on. Not only does this help students learn, but it can also make them work more efficiently by saving time, as it provides a solution for tedious calculations that would otherwise require manual effort. These calculations, though simple, can take extra time that is vital in a laboratory or lecture-type environment.</p>
</section>
<section id="computational-thinking" class="level4">
<h4 class="anchored" data-anchor-id="computational-thinking">2. Computational Thinking</h4>
<p>This project also encourages interdisciplinary learning. It teaches programming concepts in a scientific context, allowing these concepts to be visualized in an easy-to-understand STEM-related discipline. For me, this project itself helped me understand what I was doing when writing the code and how I would achieve my desired outcome.</p>
</section>
<section id="scientific-research" class="level4">
<h4 class="anchored" data-anchor-id="scientific-research">3. Scientific Research</h4>
<p>Researchers and lab technicians frequently calculate molar masses while preparing chemical solutions. Automating this process ensures accuracy, consistency, and efficiency, particularly when dealing with large datasets or repetitive calculations. As a biology major currently enrolled in chemistry courses, I understand the significance of atomic mass and have applied it numerous times throughout my coursework. Atomic mass is a key component in quantitative analysis, enabling the determination of the amount of a substance used or needed in an experiment. It also helps to identify unknown compounds using concepts like spectrometry. In nuclear chemistry, Atomic mass is extremely crucial as it is the key to understanding radioactive decay and nuclear reactions. This is how scientists can date organic materials. It also plays a role in calculating the energy changes in chemical reactions using thermochemistry.</p>
</section>
<section id="reproducibility" class="level4">
<h4 class="anchored" data-anchor-id="reproducibility">4. Reproducibility</h4>
<p>By using Quarto and GitHub Pages, results are fully reproducible. This means that this exact code can be utilized by those in need of a quick solution to complete these calculations. This GitHub repository is public, allowing anyone with access to the link to complete these calculations using the project.</p>
</section>
</section>
<section id="struggles-and-challenges-faced" class="level2">
<h2 class="anchored" data-anchor-id="struggles-and-challenges-faced">Struggles and Challenges Faced</h2>
<p>This project was extremely challenging for me, as it was very complex and intricate, despite the main goal being relatively simple. I struggled with developing several challenges, which were addressed throughout the process. Here I listed some of the main challenges I encountered: 1. Parsing multi-digit atom counts and multi-letter elements was very confusing for me. My original code failed with formulas like C12H22O11 or NaCl because I had only designed the code to recognise elements with one letter or their count being on. I fixed this issue by adding a loop (i) to check each letter and digit to see if there was more than just one. 3. Another problem I ironed out was displaying tables and graphs in Quarto vs my GitHub repository. needed to return the DataFrame (df) instead of using print().Required plt.show() to ensure the pie chart renders correctly on my Quarto document. Then I needed to format them differently so that they would display correctly in my GitHub repository. 4. I also struggled with the symbolic representation portion. Using SymPy was challenging, and it required precise settings to produce valid LaTeX in Quarto. 5. My final considerable struggle was my GitHub pages rendering. I finally understood that Quarto must render .qmd to HTML before pushing, which was a tedious task to perform repeatedly while editing the code.</p>
</section>
<section id="summary" class="level2">
<h2 class="anchored" data-anchor-id="summary">Summary</h2>
<p>This project demonstrates how to calculate and visualize the molar mass of chemical compounds programmatically using Python, pandas, matplotlib, and SymPy within a Quarto document. By combining these tools, the project not only automates tedious calculations but also provides insights that are visually and mathematically meaningful, making it a versatile tool for students, educators, and researchers alike. It parses chemical formulas, counts atoms, calculates the total molecular mass, displays the results in a table, and creates a pie chart showing the contribution of each element. Then it creates a symbolic representation with SymPy and links numeric calculations to chemical formulas. Finally, by publishing on GitHub Pages, the workflow becomes reproducible and shareable, making it a practical tool for education, research, and demonstrating the integration of computation into chemistry.</p>
</section>
<section id="possible-project-extension" class="level2">
<h2 class="anchored" data-anchor-id="possible-project-extension">Possible Project Extension</h2>
<p>Although this project is extremely helpful in calculating molar mass for a molecule, there is more that can be done to make this tool even more effective. In chemistry, there are groups of ions (charged particles) called polyatomic ions. Polyatomic ions are compounds that behave as a single element even though they have multiple elements that make them up. Hydroxide (OH^-) is a perfect example. Although there is one oxygen and one hydrogen, this ion has a negative charge and behaves like a single element. This would be a problem for my current code because when it encounters a compound like Calcium Hydroxide, or Ca(OH)2, it would not recognize that, in this instance, OH is considered a single element. Further changes to the formula parsing function can be made to allow the polyatomic ions and their parentheses to be recognized and factored in when a compound containing one is encountered.</p>
<p>Another addition to the project could be tweaking the code to handle multiple batches of compounds simultaneously, and potentially even combine them. In a laboratory setting, numerous chemicals are used, and all of them are typically extremely large compounds. To make researchers even more efficient, we can enable them to perform numerous calculations of varying sizes all at once.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>